package uk.ac.ucl.jsh.parser;

import uk.ac.ucl.jsh.JshGrammarBaseVisitor;
import uk.ac.ucl.jsh.JshGrammarParser;
import uk.ac.ucl.jsh.command.Call;
import uk.ac.ucl.jsh.command.Command;
import uk.ac.ucl.jsh.command.Pipe;
import uk.ac.ucl.jsh.command.Sequence;


/**
 * Visitor class that traverse through the Abstract syntax tree generated by the 
 * ANTLR plugin.
 */
public class CommandVisitor extends JshGrammarBaseVisitor<Command> {

    /**
     * Visit the Cmdline token from the syntax tree. Grammar in CallGrammar.g4
     * This is the token at the root of the syntax tree.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */
    @Override
    public Command visitCmdline(JshGrammarParser.CmdlineContext ctx) {
        if (ctx.seq() != null) {
            return visit(ctx.seq());
        }
        return visit(ctx.command());
    }

    /**
     * Visit the Command token from the syntax tree. Grammar in CallGrammar.g4
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */
    @Override
    public Command visitCommand(JshGrammarParser.CommandContext ctx) {
        if (ctx.pipe() != null) {
            return visit(ctx.pipe());
        }
        return visit(ctx.call());
    }

    /**
     * Visit the SeqRecur token from the syntax tree. Grammar in CallGrammar.g4
     * This specify the recursively defined command of type seqeuence.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */
    @Override
    public Command visitSeqRecur(JshGrammarParser.SeqRecurContext ctx) {
        return new Sequence(visit(ctx.cmd1), visit(ctx.cmd2));
    }
    
    /**
     * Visit the SeqBase token from the syntax tree. Grammar in CallGrammar.g4
     * This defines a single command of type sequence.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */
    @Override
    public Command visitSeqBase(JshGrammarParser.SeqBaseContext ctx) {
        return new Sequence(visit(ctx.seq()), visit(ctx.command()));
    }

    /**
     * Visit the MultiCallPipe token from the syntax tree. Grammar in CallGrammar.g4
     * This specify the recursively defined command of type Pipe.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */
    @Override
    public Command visitMultiCallPipe(JshGrammarParser.MultiCallPipeContext ctx) {
        return new Pipe(visit(ctx.pipe()), visit(ctx.call()));
    }

    /**
     * Visit the CallOnlyPipe token from the syntax tree. Grammar in CallGrammar.g4
     * This defines a single command of type pipe.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */    
    @Override
    public Command visitCallOnlyPipe(JshGrammarParser.CallOnlyPipeContext ctx) {
        return new Pipe(visit(ctx.call1), visit(ctx.call2));
    }

    /**
     * Visit the Call token from the syntax tree. Grammar in CallGrammar.g4
     * This defines a single command of type Call.
     * 
     * @param ctx Current node in the syntax tree that we are visiting.
     */ 
    @Override
    public Command visitCall(JshGrammarParser.CallContext ctx) {
        return new Call(ctx.getText());
    }
}

